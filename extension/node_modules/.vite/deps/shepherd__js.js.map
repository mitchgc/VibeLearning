{
  "version": 3,
  "sources": ["../../../../node_modules/shepherd.js/src/utils/type-check.ts", "../../../../node_modules/shepherd.js/src/evented.ts", "../../../../node_modules/node_modules/.pnpm/deepmerge-ts@7.1.1/node_modules/deepmerge-ts/dist/index.mjs", "../../../../node_modules/shepherd.js/src/utils/auto-bind.ts", "../../../../node_modules/shepherd.js/src/utils/bind.ts", "../../../../node_modules/shepherd.js/src/utils/general.ts", "../../../../node_modules/node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../../../../node_modules/node_modules/.pnpm/@floating-ui+core@1.7.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../../../../node_modules/node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs", "../../../../node_modules/node_modules/.pnpm/@floating-ui+dom@1.7.0/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../../../../node_modules/shepherd.js/src/utils/floating-ui.ts", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/utils.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/dom.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/lifecycle.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/scheduler.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/transitions.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/each.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/spread.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/Component.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/shared/version.js", "../../../../node_modules/node_modules/.pnpm/svelte@4.2.19/node_modules/svelte/src/runtime/internal/disclose-version/index.js", "../../../../node_modules/shepherd.js/src/components/shepherd-button.svelte", "../../../../node_modules/shepherd.js/src/components/shepherd-footer.svelte", "../../../../node_modules/shepherd.js/src/components/shepherd-cancel-icon.svelte", "../../../../node_modules/shepherd.js/src/components/shepherd-title.svelte", "../../../../node_modules/shepherd.js/src/components/shepherd-header.svelte", "../../../../node_modules/shepherd.js/src/components/shepherd-text.svelte", "../../../../node_modules/shepherd.js/src/components/shepherd-content.svelte", "../../../../node_modules/shepherd.js/src/components/shepherd-element.svelte", "../../../../node_modules/shepherd.js/src/step.ts", "../../../../node_modules/shepherd.js/src/utils/cleanup.ts", "../../../../node_modules/shepherd.js/src/utils/overlay-path.ts", "../../../../node_modules/shepherd.js/src/components/shepherd-modal.svelte", "../../../../node_modules/shepherd.js/src/tour.ts", "../../../../node_modules/shepherd.js/src/shepherd.ts"],
  "sourcesContent": ["/**\n * Checks if `value` is classified as an `Element`.\n * @param value The param to check if it is an Element\n */\nexport function isElement<T>(value: T | Element): value is Element {\n  return value instanceof Element;\n}\n\n/**\n * Checks if `value` is classified as an `HTMLElement`.\n * @param value The param to check if it is an HTMLElement\n */\nexport function isHTMLElement<T>(value: T | HTMLElement): value is HTMLElement {\n  return value instanceof HTMLElement;\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n * @param value The param to check if it is a function\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction<T>(value: T | Function): value is Function {\n  return typeof value === 'function';\n}\n\n/**\n * Checks if `value` is classified as a `String` object.\n * @param value The param to check if it is a string\n */\nexport function isString<T>(value: T | string): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Checks if `value` is undefined.\n * @param value The param to check if it is undefined\n */\nexport function isUndefined<T>(value: T | undefined): value is undefined {\n  return value === undefined;\n}\n", "import { isUndefined } from './utils/type-check.ts';\n\nexport type Bindings = {\n  [key: string]: Array<{ handler: () => void; ctx?: unknown; once?: boolean }>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AnyHandler = (...args: any[]) => void;\n\nexport class Evented {\n  declare bindings: Bindings;\n\n  /**\n   * Adds an event listener for the given event string.\n   *\n   * @param {string} event\n   * @param {Function} handler\n   * @param ctx\n   * @param {boolean} once\n   * @returns\n   */\n  on(event: string, handler: AnyHandler, ctx?: unknown, once = false) {\n    if (isUndefined(this.bindings)) {\n      this.bindings = {};\n    }\n    if (isUndefined(this.bindings[event])) {\n      this.bindings[event] = [];\n    }\n    this.bindings[event]?.push({ handler, ctx, once });\n\n    return this;\n  }\n\n  /**\n   * Adds an event listener that only fires once for the given event string.\n   *\n   * @param {string} event\n   * @param {Function} handler\n   * @param ctx\n   * @returns\n   */\n  once(event: string, handler: AnyHandler, ctx?: unknown) {\n    return this.on(event, handler, ctx, true);\n  }\n\n  /**\n   * Removes an event listener for the given event string.\n   *\n   * @param {string} event\n   * @param {Function} handler\n   * @returns\n   */\n  off(event: string, handler?: AnyHandler) {\n    if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n      return this;\n    }\n\n    if (isUndefined(handler)) {\n      delete this.bindings[event];\n    } else {\n      this.bindings[event]?.forEach((binding, index) => {\n        if (binding.handler === handler) {\n          this.bindings[event]?.splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Triggers an event listener for the given event string.\n   *\n   * @param {string} event\n   * @returns\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  trigger(event: string, ...args: any[]) {\n    if (!isUndefined(this.bindings) && this.bindings[event]) {\n      this.bindings[event]?.forEach((binding, index) => {\n        const { ctx, handler, once } = binding;\n\n        const context = ctx || this;\n\n        handler.apply(context, args as []);\n\n        if (once) {\n          this.bindings[event]?.splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n}\n", "/**\n * Special values that tell deepmerge to perform a certain action.\n */\nconst actions = {\n    defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n    skip: Symbol(\"deepmerge-ts: skip\"),\n};\n/**\n * Special values that tell deepmergeInto to perform a certain action.\n */\nconst actionsInto = {\n    defaultMerge: actions.defaultMerge,\n};\n\n/**\n * The default function to update meta data.\n *\n * It doesn't update the meta data.\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n    return metaMeta;\n}\n/**\n * The default function to filter values.\n *\n * It filters out undefined values.\n */\nfunction defaultFilterValues(values, meta) {\n    return values.filter((value) => value !== undefined);\n}\n\n/**\n * The different types of objects deepmerge-ts support.\n */\nvar ObjectType;\n(function (ObjectType) {\n    ObjectType[ObjectType[\"NOT\"] = 0] = \"NOT\";\n    ObjectType[ObjectType[\"RECORD\"] = 1] = \"RECORD\";\n    ObjectType[ObjectType[\"ARRAY\"] = 2] = \"ARRAY\";\n    ObjectType[ObjectType[\"SET\"] = 3] = \"SET\";\n    ObjectType[ObjectType[\"MAP\"] = 4] = \"MAP\";\n    ObjectType[ObjectType[\"OTHER\"] = 5] = \"OTHER\";\n})(ObjectType || (ObjectType = {}));\n/**\n * Get the type of the given object.\n *\n * @param object - The object to get the type of.\n * @returns The type of the given object.\n */\nfunction getObjectType(object) {\n    if (typeof object !== \"object\" || object === null) {\n        return 0 /* ObjectType.NOT */;\n    }\n    if (Array.isArray(object)) {\n        return 2 /* ObjectType.ARRAY */;\n    }\n    if (isRecord(object)) {\n        return 1 /* ObjectType.RECORD */;\n    }\n    if (object instanceof Set) {\n        return 3 /* ObjectType.SET */;\n    }\n    if (object instanceof Map) {\n        return 4 /* ObjectType.MAP */;\n    }\n    return 5 /* ObjectType.OTHER */;\n}\n/**\n * Get the keys of the given objects including symbol keys.\n *\n * Note: Only keys to enumerable properties are returned.\n *\n * @param objects - An array of objects to get the keys of.\n * @returns A set containing all the keys of all the given objects.\n */\nfunction getKeys(objects) {\n    const keys = new Set();\n    for (const object of objects) {\n        for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n            keys.add(key);\n        }\n    }\n    return keys;\n}\n/**\n * Does the given object have the given property.\n *\n * @param object - The object to test.\n * @param property - The property to test.\n * @returns Whether the object has the property.\n */\nfunction objectHasProperty(object, property) {\n    return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\n * Get an iterable object that iterates over the given iterables.\n */\nfunction getIterableOfIterables(iterables) {\n    return {\n        *[Symbol.iterator]() {\n            for (const iterable of iterables) {\n                for (const value of iterable) {\n                    yield value;\n                }\n            }\n        },\n    };\n}\nconst validRecordToStringValues = new Set([\"[object Object]\", \"[object Module]\"]);\n/**\n * Does the given object appear to be a record.\n */\nfunction isRecord(value) {\n    // All records are objects.\n    if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {\n        return false;\n    }\n    const { constructor } = value;\n    // If has modified constructor.\n    // eslint-disable-next-line ts/no-unnecessary-condition\n    if (constructor === undefined) {\n        return true;\n    }\n    const prototype = constructor.prototype;\n    // If has modified prototype.\n    if (prototype === null ||\n        typeof prototype !== \"object\" ||\n        !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {\n        return false;\n    }\n    // If constructor does not have an Object-specific method.\n    // eslint-disable-next-line sonar/prefer-single-boolean-return, no-prototype-builtins\n    if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n        return false;\n    }\n    // Most likely a record.\n    return true;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$1(values, utils, meta) {\n    const result = {};\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n        if (propertyResult === actions.skip) {\n            continue;\n        }\n        if (key === \"__proto__\") {\n            Object.defineProperty(result, key, {\n                value: propertyResult,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            result[key] = propertyResult;\n        }\n    }\n    return result;\n}\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$1(values) {\n    return values.flat();\n}\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$1(values) {\n    return new Set(getIterableOfIterables(values));\n}\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$1(values) {\n    return new Map(getIterableOfIterables(values));\n}\n/**\n * Get the last non-undefined value in the given array.\n */\nfunction mergeOthers$1(values) {\n    return values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeFunctions = {\n    mergeRecords: mergeRecords$1,\n    mergeArrays: mergeArrays$1,\n    mergeSets: mergeSets$1,\n    mergeMaps: mergeMaps$1,\n    mergeOthers: mergeOthers$1,\n};\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nfunction deepmerge(...objects) {\n    return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n    const utils = getUtils(options, customizedDeepmerge);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmerge(...objects) {\n        return mergeUnknowns(objects, utils, rootMetaData);\n    }\n    return customizedDeepmerge;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getUtils(options, customizedDeepmerge) {\n    return {\n        defaultMergeFunctions: mergeFunctions,\n        mergeFunctions: {\n            ...mergeFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmerge: customizedDeepmerge,\n        useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions,\n    };\n}\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns(values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return undefined;\n    }\n    if (filteredValues.length === 1) {\n        return mergeOthers(filteredValues, utils, meta);\n    }\n    const type = getObjectType(filteredValues[0]);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n            if (getObjectType(filteredValues[m_index]) === type) {\n                continue;\n            }\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return mergeRecords(filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return mergeArrays(filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return mergeSets(filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return mergeMaps(filteredValues, utils, meta);\n        }\n        default: {\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords)) {\n        return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n    }\n    return result;\n}\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays)) {\n        return utils.defaultMergeFunctions.mergeArrays(values);\n    }\n    return result;\n}\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)) {\n        return utils.defaultMergeFunctions.mergeSets(values);\n    }\n    return result;\n}\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)) {\n        return utils.defaultMergeFunctions.mergeMaps(values);\n    }\n    return result;\n}\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers)) {\n        return utils.defaultMergeFunctions.mergeOthers(values);\n    }\n    return result;\n}\n\n/**\n * The default strategy to merge records into a target record.\n *\n * @param m_target - The result will be mutated into this record\n * @param values - The records (including the target's value if there is one).\n */\nfunction mergeRecordsInto$1(m_target, values, utils, meta) {\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyTarget = { value: propValues[0] };\n        mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n        if (key === \"__proto__\") {\n            Object.defineProperty(m_target.value, key, {\n                value: propertyTarget.value,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            m_target.value[key] = propertyTarget.value;\n        }\n    }\n}\n/**\n * The default strategy to merge arrays into a target array.\n *\n * @param m_target - The result will be mutated into this array\n * @param values - The arrays (including the target's value if there is one).\n */\nfunction mergeArraysInto$1(m_target, values) {\n    m_target.value.push(...values.slice(1).flat());\n}\n/**\n * The default strategy to merge sets into a target set.\n *\n * @param m_target - The result will be mutated into this set\n * @param values - The sets (including the target's value if there is one).\n */\nfunction mergeSetsInto$1(m_target, values) {\n    for (const value of getIterableOfIterables(values.slice(1))) {\n        m_target.value.add(value);\n    }\n}\n/**\n * The default strategy to merge maps into a target map.\n *\n * @param m_target - The result will be mutated into this map\n * @param values - The maps (including the target's value if there is one).\n */\nfunction mergeMapsInto$1(m_target, values) {\n    for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n        m_target.value.set(key, value);\n    }\n}\n/**\n * Set the target to the last non-undefined value.\n */\nfunction mergeOthersInto$1(m_target, values) {\n    m_target.value = values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeIntoFunctions = {\n    mergeRecords: mergeRecordsInto$1,\n    mergeArrays: mergeArraysInto$1,\n    mergeSets: mergeSetsInto$1,\n    mergeMaps: mergeMapsInto$1,\n    mergeOthers: mergeOthersInto$1,\n};\n\nfunction deepmergeInto(target, ...objects) {\n    return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n    const utils = getIntoUtils(options, customizedDeepmergeInto);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmergeInto(target, ...objects) {\n        mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);\n    }\n    return customizedDeepmergeInto;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n    return {\n        defaultMergeFunctions: mergeIntoFunctions,\n        mergeFunctions: {\n            ...mergeIntoFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeIntoFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeIntoFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmergeInto: customizedDeepmergeInto,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions: actionsInto,\n    };\n}\n/**\n * Merge unknown things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The values.\n */\nfunction mergeUnknownsInto(m_target, values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return;\n    }\n    if (filteredValues.length === 1) {\n        return void mergeOthersInto(m_target, filteredValues, utils, meta);\n    }\n    const type = getObjectType(m_target.value);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let m_index = 1; m_index < filteredValues.length; m_index++) {\n            if (getObjectType(filteredValues[m_index]) === type) {\n                continue;\n            }\n            return void mergeOthersInto(m_target, filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return void mergeRecordsInto(m_target, filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return void mergeArraysInto(m_target, filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return void mergeSetsInto(m_target, filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return void mergeMapsInto(m_target, filteredValues, utils, meta);\n        }\n        default: {\n            return void mergeOthersInto(m_target, filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records into a target record.\n *\n * @param m_target - The target to merge into.\n * @param values - The records.\n */\nfunction mergeRecordsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);\n    }\n}\n/**\n * Merge arrays into a target array.\n *\n * @param m_target - The target to merge into.\n * @param values - The arrays.\n */\nfunction mergeArraysInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeArrays(m_target, values);\n    }\n}\n/**\n * Merge sets into a target set.\n *\n * @param m_target - The target to merge into.\n * @param values - The sets.\n */\nfunction mergeSetsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeSets(m_target, values);\n    }\n}\n/**\n * Merge maps into a target map.\n *\n * @param m_target - The target to merge into.\n * @param values - The maps.\n */\nfunction mergeMapsInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeMaps(m_target, values);\n    }\n}\n/**\n * Merge other things into a target.\n *\n * @param m_target - The target to merge into.\n * @param values - The other things.\n */\nfunction mergeOthersInto(m_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeOthers(m_target, values);\n    }\n}\n\nexport { deepmerge, deepmergeCustom, deepmergeInto, deepmergeIntoCustom, getKeys, getObjectType, objectHasProperty };\n", "/**\n * Binds all the methods on a JS Class to the `this` context of the class.\n * Adapted from https://github.com/sindresorhus/auto-bind\n * @param self The `this` context of the class\n * @return The `this` context of the class\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default function autoBind(self: any) {\n  const keys = Object.getOwnPropertyNames(self.constructor.prototype);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as keyof typeof self;\n    const val = self[key];\n    if (key !== 'constructor' && typeof val === 'function') {\n      self[key] = val.bind(self);\n    }\n  }\n\n  return self;\n}\n", "import type { Step } from '../step.ts';\nimport { isUndefined } from './type-check.ts';\n\n/**\n * Sets up the handler to determine if we should advance the tour\n * @param step The step instance\n * @param selector\n * @private\n */\nfunction _setupAdvanceOnHandler(step: Step, selector?: string) {\n  return (event: Event) => {\n    if (step.isOpen()) {\n      const targetIsEl = step.el && event.currentTarget === step.el;\n      const targetIsSelector =\n        !isUndefined(selector) &&\n        (event.currentTarget as HTMLElement).matches(selector);\n\n      if (targetIsSelector || targetIsEl) {\n        step.tour.next();\n      }\n    }\n  };\n}\n\n/**\n * Bind the event handler for advanceOn\n * @param step The step instance\n */\nexport function bindAdvance(step: Step) {\n  // An empty selector matches the step element\n  const { event, selector } = step.options.advanceOn || {};\n  if (event) {\n    const handler = _setupAdvanceOnHandler(step, selector);\n\n    // TODO: this should also bind/unbind on show/hide\n    let el: Element | null = null;\n\n    if (!isUndefined(selector)) {\n      el = document.querySelector(selector);\n\n      if (!el) {\n        return console.error(\n          `No element was found for the selector supplied to advanceOn: ${selector}`\n        );\n      }\n    }\n\n    if (el) {\n      el.addEventListener(event, handler);\n      step.on('destroy', () => {\n        return (el as HTMLElement).removeEventListener(event, handler);\n      });\n    } else {\n      document.body.addEventListener(event, handler, true);\n      step.on('destroy', () => {\n        return document.body.removeEventListener(event, handler, true);\n      });\n    }\n  } else {\n    return console.error(\n      'advanceOn was defined, but no event name was passed.'\n    );\n  }\n}\n", "import { type Tour, type TourOptions } from '../tour.ts';\nimport {\n  type StepOptionsAttachTo,\n  type Step,\n  type StepOptions\n} from '../step.ts';\nimport { isFunction, isString } from './type-check.ts';\n\nexport class StepNoOp {\n  constructor(_options: StepOptions) {}\n}\n\nexport class TourNoOp {\n  constructor(_tour: Tour, _options: TourOptions) {}\n}\n\n/**\n * Ensure class prefix ends in `-`\n * @param prefix - The prefix to prepend to the class names generated by nano-css\n * @return The prefix ending in `-`\n */\nexport function normalizePrefix(prefix?: string) {\n  if (!isString(prefix) || prefix === '') {\n    return '';\n  }\n\n  return prefix.charAt(prefix.length - 1) !== '-' ? `${prefix}-` : prefix;\n}\n\n/**\n * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n * @param step - The step instance\n * @returns {{}|{element, on}}\n * `element` is a qualified HTML Element\n * `on` is a string position value\n */\nexport function parseAttachTo(step: Step) {\n  const options = step.options.attachTo || {};\n  const returnOpts = Object.assign({}, options);\n\n  if (isFunction(returnOpts.element)) {\n    // Bind the callback to step so that it has access to the object, to enable running additional logic\n    returnOpts.element = returnOpts.element.call(step);\n  }\n\n  if (isString(returnOpts.element)) {\n    // Can't override the element in user opts reference because we can't\n    // guarantee that the element will exist in the future.\n    try {\n      returnOpts.element = document.querySelector(\n        returnOpts.element\n      ) as HTMLElement;\n    } catch (e) {\n      // TODO\n    }\n    if (!returnOpts.element) {\n      console.error(\n        `The element for this Shepherd step was not found ${options.element}`\n      );\n    }\n  }\n\n  return returnOpts;\n}\n\n/*\n * Resolves the step's `extraHighlights` option, converting any locator values to HTMLElements.\n */\nexport function parseExtraHighlights(step: Step): HTMLElement[] {\n  if (step.options.extraHighlights) {\n    return step.options.extraHighlights.flatMap((highlight) => {\n      return Array.from(document.querySelectorAll(highlight)) as HTMLElement[];\n    });\n  }\n  return [];\n}\n\n/**\n * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n * alternative for the deprecated step.isCentered() method.\n */\nexport function shouldCenterStep(resolvedAttachToOptions: StepOptionsAttachTo) {\n  if (\n    resolvedAttachToOptions === undefined ||\n    resolvedAttachToOptions === null\n  ) {\n    return true;\n  }\n\n  return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n}\n\n/**\n * Create a unique id for steps, tours, modals, etc\n */\nexport function uuid() {\n  let d = Date.now();\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          var _overflowsData$;\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;\n          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n", "import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n", "import { deepmerge } from 'deepmerge-ts';\nimport { shouldCenterStep } from './general.ts';\nimport {\n  autoUpdate,\n  arrow,\n  computePosition,\n  flip,\n  autoPlacement,\n  limitShift,\n  shift,\n  type ComputePositionConfig,\n  type MiddlewareData,\n  type Placement,\n  type Alignment\n} from '@floating-ui/dom';\nimport type { Step, StepOptions, StepOptionsAttachTo } from '../step.ts';\nimport { isHTMLElement } from './type-check.ts';\n\n/**\n * Determines options for the tooltip and initializes event listeners.\n *\n * @param step The step instance\n */\nexport function setupTooltip(step: Step): ComputePositionConfig {\n  if (step.cleanup) {\n    step.cleanup();\n  }\n\n  const attachToOptions = step._getResolvedAttachToOptions();\n\n  let target = attachToOptions.element as HTMLElement;\n  const floatingUIOptions = getFloatingUIOptions(attachToOptions, step);\n  const shouldCenter = shouldCenterStep(attachToOptions);\n\n  if (shouldCenter) {\n    target = document.body;\n    // @ts-expect-error TODO: fix this type error when we type Svelte\n    const content = step.shepherdElementComponent.getElement();\n    content.classList.add('shepherd-centered');\n  }\n\n  step.cleanup = autoUpdate(target, step.el as HTMLElement, () => {\n    // The element might have already been removed by the end of the tour.\n    if (!step.el) {\n      step.cleanup?.();\n      return;\n    }\n\n    setPosition(target, step, floatingUIOptions, shouldCenter);\n  });\n\n  step.target = attachToOptions.element as HTMLElement;\n\n  return floatingUIOptions;\n}\n\n/**\n * Merge tooltip options handling nested keys.\n *\n * @param tourOptions - The default tour options.\n * @param options - Step specific options.\n *\n * @return {floatingUIOptions: FloatingUIOptions}\n */\nexport function mergeTooltipConfig(\n  tourOptions: StepOptions,\n  options: StepOptions\n): { floatingUIOptions: ComputePositionConfig } {\n  return {\n    floatingUIOptions: deepmerge(\n      tourOptions.floatingUIOptions || {},\n      options.floatingUIOptions || {}\n    )\n  };\n}\n\n/**\n * Cleanup function called when the step is closed/destroyed.\n *\n * @param step\n */\nexport function destroyTooltip(step: Step) {\n  if (step.cleanup) {\n    step.cleanup();\n  }\n\n  step.cleanup = null;\n}\n\nfunction setPosition(\n  target: HTMLElement,\n  step: Step,\n  floatingUIOptions: ComputePositionConfig,\n  shouldCenter: boolean\n) {\n  return (\n    computePosition(target, step.el as HTMLElement, floatingUIOptions)\n      .then(floatingUIposition(step, shouldCenter))\n      // Wait before forcing focus.\n      .then(\n        (step: Step) =>\n          new Promise<Step>((resolve) => {\n            setTimeout(() => resolve(step), 300);\n          })\n      )\n      // Replaces focusAfterRender modifier.\n      .then((step: Step) => {\n        if (step?.el) {\n          step.el.tabIndex = 0;\n          step.el.focus({ preventScroll: true });\n        }\n      })\n  );\n}\n\nfunction floatingUIposition(step: Step, shouldCenter: boolean) {\n  return ({\n    x,\n    y,\n    placement,\n    middlewareData\n  }: {\n    x: number;\n    y: number;\n    placement: Placement;\n    middlewareData: MiddlewareData;\n  }) => {\n    if (!step.el) {\n      return step;\n    }\n\n    if (shouldCenter) {\n      Object.assign(step.el.style, {\n        position: 'fixed',\n        left: '50%',\n        top: '50%',\n        transform: 'translate(-50%, -50%)'\n      });\n    } else {\n      Object.assign(step.el.style, {\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`\n      });\n    }\n\n    step.el.dataset['popperPlacement'] = placement;\n\n    placeArrow(step.el, middlewareData);\n\n    return step;\n  };\n}\n\nfunction placeArrow(el: HTMLElement, middlewareData: MiddlewareData) {\n  const arrowEl = el.querySelector('.shepherd-arrow');\n  if (isHTMLElement(arrowEl) && middlewareData.arrow) {\n    const { x: arrowX, y: arrowY } = middlewareData.arrow;\n    Object.assign(arrowEl.style, {\n      left: arrowX != null ? `${arrowX}px` : '',\n      top: arrowY != null ? `${arrowY}px` : ''\n    });\n  }\n}\n\n/**\n * Gets the `Floating UI` options from a set of base `attachTo` options\n * @param attachToOptions\n * @param step The step instance\n * @private\n */\nexport function getFloatingUIOptions(\n  attachToOptions: StepOptionsAttachTo,\n  step: Step\n): ComputePositionConfig {\n  const options: ComputePositionConfig = {\n    strategy: 'absolute'\n  };\n\n  options.middleware = [];\n\n  const arrowEl = addArrow(step);\n\n  const shouldCenter = shouldCenterStep(attachToOptions);\n\n  const hasAutoPlacement = attachToOptions.on?.includes('auto');\n\n  const hasEdgeAlignment =\n    attachToOptions?.on?.includes('-start') ||\n    attachToOptions?.on?.includes('-end');\n\n  if (!shouldCenter) {\n    if (hasAutoPlacement) {\n      options.middleware.push(\n        autoPlacement({\n          crossAxis: true,\n          alignment: hasEdgeAlignment\n            ? (attachToOptions?.on?.split('-').pop() as Alignment)\n            : null\n        })\n      );\n    } else {\n      options.middleware.push(flip());\n    }\n\n    options.middleware.push(\n      // Replicate PopperJS default behavior.\n      shift({\n        limiter: limitShift(),\n        crossAxis: true\n      })\n    );\n\n    if (arrowEl) {\n      const arrowOptions =\n        typeof step.options.arrow === 'object'\n          ? step.options.arrow\n          : { padding: 4 };\n\n      options.middleware.push(\n        arrow({\n          element: arrowEl,\n          padding: hasEdgeAlignment ? arrowOptions.padding : 0\n        })\n      );\n    }\n\n    if (!hasAutoPlacement) options.placement = attachToOptions.on as Placement;\n  }\n\n  return deepmerge(options, step.options.floatingUIOptions || {});\n}\n\nfunction addArrow(step: Step) {\n  if (step.options.arrow && step.el) {\n    return step.el.querySelector('.shepherd-arrow');\n  }\n\n  return false;\n}\n", "/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n", "import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tif (claimed_nodes.length === 0) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt;'\n};\n\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nexport function stringify_spread(attributes) {\n\tlet str = ' ';\n\tfor (const key in attributes) {\n\t\tif (attributes[key] != null) {\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n", "import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n", "import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n", "import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro  restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro  we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro  needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n", "import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n", "/** @returns {{}} */\nexport function get_spread_update(levels, updates) {\n\tconst update = {};\n\tconst to_null_out = {};\n\tconst accounted_for = { $$scope: 1 };\n\tlet i = levels.length;\n\twhile (i--) {\n\t\tconst o = levels[i];\n\t\tconst n = updates[i];\n\t\tif (n) {\n\t\t\tfor (const key in o) {\n\t\t\t\tif (!(key in n)) to_null_out[key] = 1;\n\t\t\t}\n\t\t\tfor (const key in n) {\n\t\t\t\tif (!accounted_for[key]) {\n\t\t\t\t\tupdate[key] = n[key];\n\t\t\t\t\taccounted_for[key] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlevels[i] = n;\n\t\t} else {\n\t\t\tfor (const key in o) {\n\t\t\t\taccounted_for[key] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const key in to_null_out) {\n\t\tif (!(key in update)) update[key] = undefined;\n\t}\n\treturn update;\n}\n\nexport function get_spread_object(spread_props) {\n\treturn typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n", "import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn || this.$$c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn && this.$$c) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n", "// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.19';\nexport const PUBLIC_VERSION = '4';\n", "import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n", "<script>\n  import { isFunction } from '../utils/type-check.ts';\n\n  export let config, step;\n  let action, classes, disabled, label, secondary, text;\n\n  $: {\n    action = config.action ? config.action.bind(step.tour) : null;\n    classes = config.classes;\n    disabled = config.disabled ? getConfigOption(config.disabled) : false;\n    label = config.label ? getConfigOption(config.label) : null;\n    secondary = config.secondary;\n    text = config.text ? getConfigOption(config.text) : null;\n  }\n\n  function getConfigOption(option) {\n    if (isFunction(option)) {\n      return (option = option.call(step));\n    }\n    return option;\n  }\n</script>\n\n<button\n  aria-label={label ? label : null}\n  class={`${classes || ''} shepherd-button ${\n    secondary ? 'shepherd-button-secondary' : ''\n  }`}\n  {disabled}\n  on:click={action}\n  tabindex=\"0\"\n  type=\"button\"\n>\n  {@html text}\n</button>\n\n<style global>\n  .shepherd-button {\n    background: rgb(50, 136, 230);\n    border: 0;\n    border-radius: 3px;\n    color: rgba(255, 255, 255, 0.75);\n    cursor: pointer;\n    margin-right: 0.5rem;\n    padding: 0.5rem 1.5rem;\n    transition: all 0.5s ease;\n  }\n\n  .shepherd-button:not(:disabled):hover {\n    background: rgb(25, 111, 204);\n    color: rgba(255, 255, 255, 0.75);\n  }\n\n  .shepherd-button.shepherd-button-secondary {\n    background: rgb(241, 242, 243);\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-button.shepherd-button-secondary:not(:disabled):hover {\n    background: rgb(214, 217, 219);\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-button:disabled {\n    cursor: not-allowed;\n  }\n</style>\n", "<script>\n  import ShepherdButton from './shepherd-button.svelte';\n\n  export let step;\n\n  $: buttons = step.options.buttons;\n</script>\n\n<footer class=\"shepherd-footer\">\n  {#if buttons}\n    {#each buttons as config}\n      <ShepherdButton {config} {step} />\n    {/each}\n  {/if}\n</footer>\n\n<style global>\n  .shepherd-footer {\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px;\n    display: flex;\n    justify-content: flex-end;\n    padding: 0 0.75rem 0.75rem;\n  }\n\n  .shepherd-footer .shepherd-button:last-child {\n    margin-right: 0;\n  }\n</style>\n", "<script>\n  export let cancelIcon, step;\n\n  /**\n   * Add a click listener to the cancel link that cancels the tour\n   */\n  const handleCancelClick = (e) => {\n    e.preventDefault();\n    step.cancel();\n  };\n</script>\n\n<button\n  aria-label={cancelIcon.label ? cancelIcon.label : 'Close Tour'}\n  class=\"shepherd-cancel-icon\"\n  on:click={handleCancelClick}\n  type=\"button\"\n>\n  <span aria-hidden=\"true\">&times;</span>\n</button>\n\n<style global>\n  .shepherd-cancel-icon {\n    background: transparent;\n    border: none;\n    color: rgba(128, 128, 128, 0.75);\n    font-size: 2em;\n    cursor: pointer;\n    font-weight: normal;\n    margin: 0;\n    padding: 0;\n    transition: color 0.5s ease;\n  }\n\n  .shepherd-cancel-icon:hover {\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-cancel-icon {\n    color: rgba(128, 128, 128, 0.75);\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-cancel-icon:hover {\n    color: rgba(0, 0, 0, 0.75);\n  }\n</style>\n", "<script>\n  import { afterUpdate } from 'svelte';\n  import { isFunction } from '../utils/type-check.ts';\n\n  export let labelId, element, title;\n\n  afterUpdate(() => {\n    if (isFunction(title)) {\n      title = title();\n    }\n\n    element.innerHTML = title;\n  });\n</script>\n\n<!-- svelte-ignore a11y-missing-content -->\n<h3 bind:this={element} id={labelId} class=\"shepherd-title\"></h3>\n\n<style global>\n  .shepherd-title {\n    color: rgba(0, 0, 0, 0.75);\n    display: flex;\n    font-size: 1rem;\n    font-weight: normal;\n    flex: 1 0 auto;\n    margin: 0;\n    padding: 0;\n  }\n</style>\n", "<script>\n  import ShepherdCancelIcon from './shepherd-cancel-icon.svelte';\n  import ShepherdTitle from './shepherd-title.svelte';\n\n  export let labelId, step;\n  let title, cancelIcon;\n\n  $: {\n    title = step.options.title;\n    cancelIcon = step.options.cancelIcon;\n  }\n</script>\n\n<header class=\"shepherd-header\">\n  {#if title}\n    <ShepherdTitle {labelId} {title} />\n  {/if}\n\n  {#if cancelIcon && cancelIcon.enabled}\n    <ShepherdCancelIcon {cancelIcon} {step} />\n  {/if}\n</header>\n\n<style global>\n  .shepherd-header {\n    align-items: center;\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px;\n    display: flex;\n    justify-content: flex-end;\n    line-height: 2em;\n    padding: 0.75rem 0.75rem 0;\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-header {\n    background: #e6e6e6;\n    padding: 1em;\n  }\n</style>\n", "<script>\n  import { afterUpdate } from 'svelte';\n  import { isHTMLElement, isFunction } from '../utils/type-check.ts';\n\n  export let descriptionId, element, step;\n\n  afterUpdate(() => {\n    let { text } = step.options;\n\n    if (isFunction(text)) {\n      text = text.call(step);\n    }\n\n    if (isHTMLElement(text)) {\n      element.appendChild(text);\n    } else {\n      element.innerHTML = text;\n    }\n  });\n</script>\n\n<div bind:this={element} class=\"shepherd-text\" id={descriptionId}></div>\n\n<style global>\n  .shepherd-text {\n    color: rgba(0, 0, 0, 0.75);\n    font-size: 1rem;\n    line-height: 1.3em;\n    padding: 0.75em;\n  }\n\n  .shepherd-text p {\n    margin-top: 0;\n  }\n\n  .shepherd-text p:last-child {\n    margin-bottom: 0;\n  }\n</style>\n", "<script>\n  import ShepherdFooter from './shepherd-footer.svelte';\n  import ShepherdHeader from './shepherd-header.svelte';\n  import ShepherdText from './shepherd-text.svelte';\n  import { isUndefined } from '../utils/type-check.ts';\n\n  export let descriptionId, labelId, step;\n</script>\n\n<div class=\"shepherd-content\">\n  {#if !isUndefined(step.options.title) || (step.options.cancelIcon && step.options.cancelIcon.enabled)}\n    <ShepherdHeader {labelId} {step} />\n  {/if}\n\n  {#if !isUndefined(step.options.text)}\n    <ShepherdText {descriptionId} {step} />\n  {/if}\n\n  {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n    <ShepherdFooter {step} />\n  {/if}\n</div>\n\n<style global>\n  .shepherd-content {\n    border-radius: 5px;\n    outline: none;\n    padding: 0;\n  }\n</style>\n", "<script>\n  import { onDestroy, onMount, afterUpdate } from 'svelte';\n  import ShepherdContent from './shepherd-content.svelte';\n  import { isUndefined, isString } from '../utils/type-check.ts';\n\n  const KEY_TAB = 9;\n  const KEY_ESC = 27;\n  const LEFT_ARROW = 37;\n  const RIGHT_ARROW = 39;\n\n  export let attachToElement,\n    attachTofocusableDialogElements,\n    classPrefix,\n    element,\n    descriptionId,\n    // Focusable attachTo elements\n    focusableAttachToElements,\n    firstFocusableAttachToElement,\n    lastFocusableAttachToElement,\n    // Focusable dialog elements\n    firstFocusableDialogElement,\n    focusableDialogElements,\n    lastFocusableDialogElement,\n    labelId,\n    step,\n    dataStepId;\n\n  let hasCancelIcon, hasTitle, classes;\n\n  $: {\n    hasCancelIcon =\n      step.options &&\n      step.options.cancelIcon &&\n      step.options.cancelIcon.enabled;\n    hasTitle = step.options && step.options.title;\n  }\n\n  export const getElement = () => element;\n\n  onMount(() => {\n    // Get all elements that are focusable\n    dataStepId = { [`data-${classPrefix}shepherd-step-id`]: step.id };\n    focusableDialogElements = [\n      ...element.querySelectorAll(\n        'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'\n      )\n    ];\n    firstFocusableDialogElement = focusableDialogElements[0];\n    lastFocusableDialogElement =\n      focusableDialogElements[focusableDialogElements.length - 1];\n\n    const attachTo = step._getResolvedAttachToOptions();\n    if (attachTo?.element) {\n      attachToElement = attachTo.element;\n      attachToElement.tabIndex = 0;\n      focusableAttachToElements = [\n        attachToElement,\n        ...attachToElement.querySelectorAll(\n          'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'\n        )\n      ];\n      firstFocusableAttachToElement = focusableAttachToElements[0];\n      lastFocusableAttachToElement =\n        focusableAttachToElements[focusableAttachToElements.length - 1];\n      // Add keydown listener to attachTo element\n      attachToElement.addEventListener('keydown', handleKeyDown);\n    }\n  });\n\n  onDestroy(() => {\n    attachToElement?.removeEventListener('keydown', handleKeyDown);\n  });\n\n  afterUpdate(() => {\n    if (classes !== step.options.classes) {\n      updateDynamicClasses();\n    }\n  });\n\n  function updateDynamicClasses() {\n    removeClasses(classes);\n    classes = step.options.classes;\n    addClasses(classes);\n  }\n\n  function removeClasses(classes) {\n    if (isString(classes)) {\n      const oldClasses = getClassesArray(classes);\n      if (oldClasses.length) {\n        element.classList.remove(...oldClasses);\n      }\n    }\n  }\n\n  function addClasses(classes) {\n    if (isString(classes)) {\n      const newClasses = getClassesArray(classes);\n      if (newClasses.length) {\n        element.classList.add(...newClasses);\n      }\n    }\n  }\n\n  function getClassesArray(classes) {\n    return classes.split(' ').filter((className) => !!className.length);\n  }\n\n  /**\n   * Setup keydown events to allow closing the modal with ESC\n   *\n   * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n   *\n   * @private\n   */\n  const handleKeyDown = (e) => {\n    const { tour } = step;\n    switch (e.keyCode) {\n      case KEY_TAB:\n        if (\n          (!focusableAttachToElements ||\n            focusableAttachToElements.length === 0) &&\n          focusableDialogElements.length === 0\n        ) {\n          e.preventDefault();\n          break;\n        }\n        // Backward tab\n        if (e.shiftKey) {\n          // If at the beginning of elements in the dialog, go to last element in attachTo\n          // If attachToElement is undefined, circle around to the last element in the dialog.\n          if (\n            document.activeElement === firstFocusableDialogElement ||\n            document.activeElement.classList.contains('shepherd-element')\n          ) {\n            e.preventDefault();\n            (\n              lastFocusableAttachToElement ?? lastFocusableDialogElement\n            ).focus();\n          }\n          // If at the beginning of elements in attachTo\n          else if (document.activeElement === firstFocusableAttachToElement) {\n            e.preventDefault();\n            lastFocusableDialogElement.focus();\n          }\n        } else {\n          if (document.activeElement === lastFocusableDialogElement) {\n            e.preventDefault();\n            (\n              firstFocusableAttachToElement ?? firstFocusableDialogElement\n            ).focus();\n          }\n          // If at the end of elements in attachTo\n          else if (document.activeElement === lastFocusableAttachToElement) {\n            e.preventDefault();\n            firstFocusableDialogElement.focus();\n          }\n        }\n        break;\n      case KEY_ESC:\n        if (tour.options.exitOnEsc) {\n          e.preventDefault();\n          e.stopPropagation();\n          step.cancel();\n        }\n        break;\n      case LEFT_ARROW:\n        if (tour.options.keyboardNavigation) {\n          e.preventDefault();\n          e.stopPropagation();\n          tour.back();\n        }\n        break;\n      case RIGHT_ARROW:\n        if (tour.options.keyboardNavigation) {\n          e.preventDefault();\n          e.stopPropagation();\n          tour.next();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n</script>\n\n<dialog\n  aria-describedby={!isUndefined(step.options.text) ? descriptionId : null}\n  aria-labelledby={step.options.title ? labelId : null}\n  bind:this={element}\n  class:shepherd-has-cancel-icon={hasCancelIcon}\n  class:shepherd-has-title={hasTitle}\n  class:shepherd-element={true}\n  {...dataStepId}\n  on:keydown={handleKeyDown}\n  open=\"true\"\n>\n  {#if step.options.arrow && step.options.attachTo && step.options.attachTo.element && step.options.attachTo.on}\n    <div class=\"shepherd-arrow\" data-popper-arrow></div>\n  {/if}\n  <ShepherdContent {descriptionId} {labelId} {step} />\n</dialog>\n\n<style global>\n  .shepherd-element {\n    background: #fff;\n    border: none;\n    border-radius: 5px;\n    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);\n    margin: 0;\n    max-width: 400px;\n    opacity: 0;\n    outline: none;\n    padding: 0;\n    transition:\n      opacity 0.3s,\n      visibility 0.3s;\n    visibility: hidden;\n    width: 100%;\n    z-index: 9999;\n  }\n\n  .shepherd-enabled.shepherd-element {\n    opacity: 1;\n    visibility: visible;\n  }\n\n  .shepherd-element[data-popper-reference-hidden]:not(.shepherd-centered) {\n    opacity: 0;\n    pointer-events: none;\n    visibility: hidden;\n  }\n\n  .shepherd-element,\n  .shepherd-element *,\n  .shepherd-element *:after,\n  .shepherd-element *:before {\n    box-sizing: border-box;\n  }\n\n  .shepherd-arrow,\n  .shepherd-arrow::before {\n    position: absolute;\n    width: 16px;\n    height: 16px;\n    z-index: -1;\n  }\n\n  .shepherd-arrow:before {\n    content: '';\n    transform: rotate(45deg);\n    background: #fff;\n  }\n\n  .shepherd-element[data-popper-placement^='top'] > .shepherd-arrow {\n    bottom: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='bottom'] > .shepherd-arrow {\n    top: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='left'] > .shepherd-arrow {\n    right: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='right'] > .shepherd-arrow {\n    left: -8px;\n  }\n\n  .shepherd-element.shepherd-centered > .shepherd-arrow {\n    opacity: 0;\n  }\n\n  /**\n  * Arrow on top of tooltip centered horizontally, with title color\n  */\n  .shepherd-element.shepherd-has-title[data-popper-placement^='bottom']\n    > .shepherd-arrow::before {\n    background-color: #e6e6e6;\n  }\n\n  .shepherd-target-click-disabled.shepherd-enabled.shepherd-target,\n  .shepherd-target-click-disabled.shepherd-enabled.shepherd-target * {\n    pointer-events: none;\n  }\n</style>\n", "import { deepmerge } from 'deepmerge-ts';\nimport { Evented } from './evented.ts';\nimport autoBind from './utils/auto-bind.ts';\nimport {\n  isElement,\n  isHTMLElement,\n  isFunction,\n  isUndefined\n} from './utils/type-check.ts';\nimport { bindAdvance } from './utils/bind.ts';\nimport {\n  parseAttachTo,\n  normalizePrefix,\n  uuid,\n  parseExtraHighlights\n} from './utils/general.ts';\nimport {\n  setupTooltip,\n  destroyTooltip,\n  mergeTooltipConfig\n} from './utils/floating-ui.ts';\n// @ts-expect-error TODO: we don't have Svelte .d.ts files until we generate the dist\nimport ShepherdElement from './components/shepherd-element.svelte';\nimport { type Tour } from './tour.ts';\nimport type { ComputePositionConfig } from '@floating-ui/dom';\n\nexport type StepText =\n  | string\n  | ReadonlyArray<string>\n  | HTMLElement\n  | (() => string | ReadonlyArray<string> | HTMLElement);\n\nexport type StringOrStringFunction = string | (() => string);\n\n/**\n * The options for the step\n */\nexport interface StepOptions {\n  /**\n   * The element the step should be attached to on the page.\n   * An object with properties `element` and `on`.\n   *\n   * ```js\n   * const step = new Step(tour, {\n   *   attachTo: { element: '.some .selector-path', on: 'left' },\n   *   ...moreOptions\n   * });\n   * ```\n   *\n   * If you dont specify an attachTo the element will appear in the middle of the screen.\n   * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n   * in the middle of the screen, without an arrow pointing to the target.\n   */\n  attachTo?: StepOptionsAttachTo;\n\n  /**\n   * An action on the page which should advance shepherd to the next step.\n   * It should be an object with a string `selector` and an `event` name\n   * ```js\n   * const step = new Step(tour, {\n   *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n   *   ...moreOptions\n   * });\n   * ```\n   * `event` doesnt have to be an event inside the tour, it can be any event fired on any element on the page.\n   * You can also always manually advance the Tour by calling `myTour.next()`.\n   */\n  advanceOn?: StepOptionsAdvanceOn;\n\n  /**\n   * Whether to display the arrow for the tooltip or not, or options for the arrow.\n   */\n  arrow?: boolean | StepOptionsArrow;\n\n  /**\n   * A function that returns a promise.\n   * When the promise resolves, the rest of the `show` code for the step will execute.\n   */\n  beforeShowPromise?: () => Promise<unknown>;\n\n  /**\n   * An array of buttons to add to the step. These will be rendered in a\n   * footer below the main body text.\n   */\n  buttons?: ReadonlyArray<StepOptionsButton>;\n\n  /**\n   * Should a cancel  be shown in the header of the step?\n   */\n  cancelIcon?: StepOptionsCancelIcon;\n\n  /**\n   * A boolean, that when set to false, will set `pointer-events: none` on the target.\n   */\n  canClickTarget?: boolean;\n\n  /**\n   * A string of extra classes to add to the step's content element.\n   */\n  classes?: string;\n\n  /**\n   * An array of extra element selectors to highlight when the overlay is shown\n   * The tooltip won't be fixed to these elements, but they will be highlighted\n   * just like the `attachTo` element.\n   * ```js\n   * const step = new Step(tour, {\n   *   extraHighlights: [ '.pricing', '#docs' ],\n   *   ...moreOptions\n   * });\n   * ```\n   */\n  extraHighlights?: ReadonlyArray<string>;\n\n  /**\n   * An extra class to apply to the `attachTo` element when it is\n   * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n   */\n  highlightClass?: string;\n\n  /**\n   * The string to use as the `id` for the step.\n   */\n  id?: string;\n\n  /**\n   * An amount of padding to add around the modal overlay opening\n   */\n  modalOverlayOpeningPadding?: number;\n\n  /**\n   * An amount of border radius to add around the modal overlay opening\n   */\n  modalOverlayOpeningRadius?:\n    | number\n    | {\n        topLeft?: number;\n        bottomLeft?: number;\n        bottomRight?: number;\n        topRight?: number;\n      };\n\n  /**\n   * An amount to offset the modal overlay opening in the x-direction\n   */\n  modalOverlayOpeningXOffset?: number;\n\n  /**\n   * An amount to offset the modal overlay opening in the y-direction\n   */\n  modalOverlayOpeningYOffset?: number;\n\n  /**\n   * Extra [options to pass to FloatingUI]{@link https://floating-ui.com/docs/tutorial/}\n   */\n  floatingUIOptions?: ComputePositionConfig;\n\n  /**\n   * Should the element be scrolled to when this step is shown?\n   */\n  scrollTo?: boolean | ScrollIntoViewOptions;\n\n  /**\n   * A function that lets you override the default scrollTo behavior and\n   * define a custom action to do the scrolling, and possibly other logic.\n   */\n  scrollToHandler?: (element: HTMLElement) => void;\n\n  /**\n   * A function that, when it returns `true`, will show the step.\n   * If it returns `false`, the step will be skipped.\n   */\n  showOn?: () => boolean;\n\n  /**\n   * The text in the body of the step. It can be one of four types:\n   * ```\n   * - HTML string\n   * - Array of HTML strings\n   * - `HTMLElement` object\n   * - `Function` to be executed when the step is built. It must return one of the three options above.\n   * ```\n   */\n  text?: StepText;\n\n  /**\n   * The step's title. It becomes an `h3` at the top of the step.\n   * ```\n   * - HTML string\n   * - `Function` to be executed when the step is built. It must return HTML string.\n   * ```\n   */\n  title?: StringOrStringFunction;\n\n  /**\n   * You can define `show`, `hide`, etc events inside `when`. For example:\n   * ```js\n   * when: {\n   *   show: function() {\n   *     window.scrollTo(0, 0);\n   *   }\n   * }\n   * ```\n   */\n  when?: StepOptionsWhen;\n}\n\nexport type PopperPlacement =\n  | 'auto'\n  | 'auto-start'\n  | 'auto-end'\n  | 'top'\n  | 'top-start'\n  | 'top-end'\n  | 'bottom'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'right'\n  | 'right-start'\n  | 'right-end'\n  | 'left'\n  | 'left-start'\n  | 'left-end';\n\nexport interface StepOptionsArrow {\n  /*\n   * The padding from the edge for the arrow.\n   * Not used if this is not a -start or -end placement.\n   */\n  padding?: number;\n}\n\nexport interface StepOptionsAttachTo {\n  element?:\n    | HTMLElement\n    | string\n    | null\n    | (() => HTMLElement | string | null | undefined);\n  on?: PopperPlacement;\n}\n\nexport interface StepOptionsAdvanceOn {\n  event: string;\n  selector: string;\n}\n\nexport interface StepOptionsButton {\n  /**\n   * A function executed when the button is clicked on\n   * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n   * work inside the action.\n   * You can use action to skip steps or navigate to specific steps, with something like:\n   * ```js\n   * action() {\n   *   return this.show('some_step_name');\n   * }\n   * ```\n   */\n  action?: (this: Tour) => void;\n\n  /**\n   * Extra classes to apply to the `<a>`\n   */\n  classes?: string;\n\n  /**\n   * Whether the button should be disabled\n   * When the value is `true`, or the function returns `true` the button will be disabled\n   */\n  disabled?: boolean | (() => boolean);\n\n  /**\n   * The aria-label text of the button\n   */\n  label?: StringOrStringFunction;\n\n  /**\n   * A boolean, that when true, adds a `shepherd-button-secondary` class to the button.\n   */\n  secondary?: boolean;\n\n  /**\n   * The HTML text of the button\n   */\n  text?: StringOrStringFunction;\n}\n\nexport interface StepOptionsButtonEvent {\n  [key: string]: () => void;\n}\n\nexport interface StepOptionsCancelIcon {\n  enabled?: boolean;\n  label?: string;\n}\n\nexport interface StepOptionsWhen {\n  [key: string]: (this: Step) => void;\n}\n\n/**\n * A class representing steps to be added to a tour.\n * @extends {Evented}\n */\nexport class Step extends Evented {\n  _resolvedAttachTo: StepOptionsAttachTo | null;\n  _resolvedExtraHighlightElements?: HTMLElement[];\n  classPrefix?: string;\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  declare cleanup: Function | null;\n  el?: HTMLElement | null;\n  declare id: string;\n  declare options: StepOptions;\n  target?: HTMLElement | null;\n  tour: Tour;\n\n  constructor(tour: Tour, options: StepOptions = {}) {\n    super();\n\n    this.tour = tour;\n    this.classPrefix = this.tour.options\n      ? normalizePrefix(this.tour.options.classPrefix)\n      : '';\n    // @ts-expect-error TODO: investigate where styles comes from\n    this.styles = tour.styles;\n\n    /**\n     * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n     * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n     * @type {StepOptionsAttachTo | null}\n     * @private\n     */\n    this._resolvedAttachTo = null;\n\n    autoBind(this);\n\n    this._setOptions(options);\n\n    return this;\n  }\n\n  /**\n   * Cancel the tour\n   * Triggers the `cancel` event\n   */\n  cancel() {\n    this.tour.cancel();\n    this.trigger('cancel');\n  }\n\n  /**\n   * Complete the tour\n   * Triggers the `complete` event\n   */\n  complete() {\n    this.tour.complete();\n    this.trigger('complete');\n  }\n\n  /**\n   * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.\n   * Triggers `destroy` event\n   */\n  destroy() {\n    destroyTooltip(this);\n\n    if (isHTMLElement(this.el)) {\n      this.el.remove();\n      this.el = null;\n    }\n\n    this._updateStepTargetOnHide();\n\n    this.trigger('destroy');\n  }\n\n  /**\n   * Returns the tour for the step\n   * @return The tour instance\n   */\n  getTour() {\n    return this.tour;\n  }\n\n  /**\n   * Hide the step\n   */\n  hide() {\n    this.tour.modal?.hide();\n\n    this.trigger('before-hide');\n\n    if (this.el) {\n      this.el.hidden = true;\n    }\n\n    this._updateStepTargetOnHide();\n\n    this.trigger('hide');\n  }\n\n  /**\n   * Resolves attachTo options.\n   * @returns {{}|{element, on}}\n   */\n  _resolveExtraHiglightElements() {\n    this._resolvedExtraHighlightElements = parseExtraHighlights(this);\n    return this._resolvedExtraHighlightElements;\n  }\n\n  /**\n   * Resolves attachTo options.\n   * @returns {{}|{element, on}}\n   */\n  _resolveAttachToOptions() {\n    this._resolvedAttachTo = parseAttachTo(this);\n    return this._resolvedAttachTo;\n  }\n\n  /**\n   * A selector for resolved attachTo options.\n   * @returns {{}|{element, on}}\n   * @private\n   */\n  _getResolvedAttachToOptions() {\n    if (this._resolvedAttachTo === null) {\n      return this._resolveAttachToOptions();\n    }\n\n    return this._resolvedAttachTo;\n  }\n\n  /**\n   * Check if the step is open and visible\n   * @return True if the step is open and visible\n   */\n  isOpen() {\n    return Boolean(this.el && !this.el.hidden);\n  }\n\n  /**\n   * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n   */\n  show() {\n    if (isFunction(this.options.beforeShowPromise)) {\n      return Promise.resolve(this.options.beforeShowPromise()).then(() =>\n        this._show()\n      );\n    }\n    return Promise.resolve(this._show());\n  }\n\n  /**\n   * Updates the options of the step.\n   *\n   * @param {StepOptions} options The options for the step\n   */\n  updateStepOptions(options: StepOptions) {\n    Object.assign(this.options, options);\n\n    // @ts-expect-error TODO: get types for Svelte components\n    if (this.shepherdElementComponent) {\n      // @ts-expect-error TODO: get types for Svelte components\n      this.shepherdElementComponent.$set({ step: this });\n    }\n  }\n\n  /**\n   * Returns the element for the step\n   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n   */\n  getElement() {\n    return this.el;\n  }\n\n  /**\n   * Returns the target for the step\n   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n   */\n  getTarget() {\n    return this.target;\n  }\n\n  /**\n   * Creates Shepherd element for step based on options\n   *\n   * @return {HTMLElement} The DOM element for the step tooltip\n   * @private\n   */\n  _createTooltipContent() {\n    const descriptionId = `${this.id}-description`;\n    const labelId = `${this.id}-label`;\n\n    // @ts-expect-error TODO: get types for Svelte components\n    this.shepherdElementComponent = new ShepherdElement({\n      target: this.tour.options.stepsContainer || document.body,\n      props: {\n        classPrefix: this.classPrefix,\n        descriptionId,\n        labelId,\n        step: this,\n        // @ts-expect-error TODO: investigate where styles comes from\n        styles: this.styles\n      }\n    });\n\n    // @ts-expect-error TODO: get types for Svelte components\n    return this.shepherdElementComponent.getElement();\n  }\n\n  /**\n   * If a custom scrollToHandler is defined, call that, otherwise do the generic\n   * scrollIntoView call.\n   *\n   * @param {boolean | ScrollIntoViewOptions} scrollToOptions - If true, uses the default `scrollIntoView`,\n   * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n   * @private\n   */\n  _scrollTo(scrollToOptions: boolean | ScrollIntoViewOptions) {\n    const { element } = this._getResolvedAttachToOptions();\n\n    if (isFunction(this.options.scrollToHandler)) {\n      this.options.scrollToHandler(element as HTMLElement);\n    } else if (\n      isElement(element) &&\n      typeof element.scrollIntoView === 'function'\n    ) {\n      element.scrollIntoView(scrollToOptions);\n    }\n  }\n\n  /**\n   * _getClassOptions gets all possible classes for the step\n   * @param {StepOptions} stepOptions The step specific options\n   * @returns {string} unique string from array of classes\n   */\n  _getClassOptions(stepOptions: StepOptions) {\n    const defaultStepOptions =\n      this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n    const stepClasses = stepOptions.classes ? stepOptions.classes : '';\n    const defaultStepOptionsClasses =\n      defaultStepOptions && defaultStepOptions.classes\n        ? defaultStepOptions.classes\n        : '';\n    const allClasses = [\n      ...stepClasses.split(' '),\n      ...defaultStepOptionsClasses.split(' ')\n    ];\n    const uniqClasses = new Set(allClasses);\n\n    return Array.from(uniqClasses).join(' ').trim();\n  }\n\n  /**\n   * Sets the options for the step, maps `when` to events, sets up buttons\n   * @param options - The options for the step\n   */\n  _setOptions(options: StepOptions = {}) {\n    let tourOptions =\n      this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n\n    tourOptions = deepmerge({}, tourOptions || {});\n\n    this.options = Object.assign(\n      {\n        arrow: true\n      },\n      tourOptions,\n      options,\n      mergeTooltipConfig(tourOptions, options)\n    );\n\n    const { when } = this.options;\n\n    this.options.classes = this._getClassOptions(options);\n\n    this.destroy();\n    this.id = this.options.id || `step-${uuid()}`;\n\n    if (when) {\n      Object.keys(when).forEach((event) => {\n        // @ts-expect-error TODO: fix this type error\n        this.on(event, when[event], this);\n      });\n    }\n  }\n\n  /**\n   * Create the element and set up the FloatingUI instance\n   * @private\n   */\n  _setupElements() {\n    if (!isUndefined(this.el)) {\n      this.destroy();\n    }\n\n    this.el = this._createTooltipContent();\n\n    if (this.options.advanceOn) {\n      bindAdvance(this);\n    }\n\n    // The tooltip implementation details are handled outside of the Step\n    // object.\n    setupTooltip(this);\n  }\n\n  /**\n   * Triggers `before-show`, generates the tooltip DOM content,\n   * sets up a FloatingUI instance for the tooltip, then triggers `show`.\n   * @private\n   */\n  _show() {\n    this.trigger('before-show');\n\n    // Force resolve to make sure the options are updated on subsequent shows.\n    this._resolveAttachToOptions();\n    this._resolveExtraHiglightElements();\n    this._setupElements();\n\n    if (!this.tour.modal) {\n      this.tour.setupModal();\n    }\n\n    this.tour.modal?.setupForStep(this);\n    this._styleTargetElementForStep(this);\n\n    if (this.el) {\n      this.el.hidden = false;\n    }\n\n    // start scrolling to target before showing the step\n    if (this.options.scrollTo) {\n      setTimeout(() => {\n        this._scrollTo(\n          this.options.scrollTo as boolean | ScrollIntoViewOptions\n        );\n      });\n    }\n\n    if (this.el) {\n      this.el.hidden = false;\n    }\n\n    // @ts-expect-error TODO: get types for Svelte components\n    const content = this.shepherdElementComponent.getElement();\n    const target = this.target || document.body;\n    const extraHighlightElements = this._resolvedExtraHighlightElements;\n\n    target.classList.add(`${this.classPrefix}shepherd-enabled`);\n    target.classList.add(`${this.classPrefix}shepherd-target`);\n    content.classList.add('shepherd-enabled');\n\n    extraHighlightElements?.forEach((el) => {\n      el.classList.add(`${this.classPrefix}shepherd-enabled`);\n      el.classList.add(`${this.classPrefix}shepherd-target`);\n    });\n\n    this.trigger('show');\n  }\n\n  /**\n   * Modulates the styles of the passed step's target element, based on the step's options and\n   * the tour's `modal` option, to visually emphasize the element\n   *\n   * @param {Step} step The step object that attaches to the element\n   * @private\n   */\n  _styleTargetElementForStep(step: Step) {\n    const targetElement = step.target;\n    const extraHighlightElements = step._resolvedExtraHighlightElements;\n\n    if (!targetElement) {\n      return;\n    }\n\n    const highlightClass = step.options.highlightClass;\n    if (highlightClass) {\n      targetElement.classList.add(highlightClass);\n      extraHighlightElements?.forEach((el) => el.classList.add(highlightClass));\n    }\n\n    targetElement.classList.remove('shepherd-target-click-disabled');\n    extraHighlightElements?.forEach((el) =>\n      el.classList.remove('shepherd-target-click-disabled')\n    );\n\n    if (step.options.canClickTarget === false) {\n      targetElement.classList.add('shepherd-target-click-disabled');\n      extraHighlightElements?.forEach((el) =>\n        el.classList.add('shepherd-target-click-disabled')\n      );\n    }\n  }\n\n  /**\n   * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n   * and 'shepherd-target' classes\n   * @private\n   */\n  _updateStepTargetOnHide() {\n    const target = this.target || document.body;\n    const extraHighlightElements = this._resolvedExtraHighlightElements;\n\n    const highlightClass = this.options.highlightClass;\n    if (highlightClass) {\n      target.classList.remove(highlightClass);\n      extraHighlightElements?.forEach((el) =>\n        el.classList.remove(highlightClass)\n      );\n    }\n\n    target.classList.remove(\n      'shepherd-target-click-disabled',\n      `${this.classPrefix}shepherd-enabled`,\n      `${this.classPrefix}shepherd-target`\n    );\n    extraHighlightElements?.forEach((el) => {\n      el.classList.remove(\n        'shepherd-target-click-disabled',\n        `${this.classPrefix}shepherd-enabled`,\n        `${this.classPrefix}shepherd-target`\n      );\n    });\n  }\n}\n", "import type { Tour } from '../tour.ts';\nimport { isHTMLElement } from './type-check.ts';\n\n/**\n * Cleanup the steps and set pointerEvents back to 'auto'\n * @param tour The tour object\n */\nexport function cleanupSteps(tour: Tour) {\n  if (tour) {\n    const { steps } = tour;\n\n    steps.forEach((step) => {\n      if (\n        step.options &&\n        step.options.canClickTarget === false &&\n        step.options.attachTo\n      ) {\n        if (isHTMLElement(step.target)) {\n          step.target.classList.remove('shepherd-target-click-disabled');\n        }\n\n        if (step._resolvedExtraHighlightElements) {\n          step._resolvedExtraHighlightElements.forEach((element) => {\n            if (isHTMLElement(element)) {\n              element.classList.remove('shepherd-target-click-disabled');\n            }\n          });\n        }\n      }\n    });\n  }\n}\n", "interface OverlayPathParams {\n  height: number;\n  r?:\n    | number\n    | {\n        bottomLeft: number;\n        bottomRight: number;\n        topLeft: number;\n        topRight: number;\n      };\n  x?: number;\n  y?: number;\n  width: number;\n}\n/**\n * Generates the svg path data for a rounded rectangle overlay\n * @param dimension - Dimensions of rectangle.\n * @param dimension.width - Width.\n * @param dimension.height - Height.\n * @param dimension.x - Offset from top left corner in x axis. default 0.\n * @param dimension.y - Offset from top left corner in y axis. default 0.\n * @param dimension.r - Corner Radius. Keep this smaller than half of width or height.\n * @returns Rounded rectangle overlay path data.\n */\nexport function makeOverlayPath(overlayPaths: OverlayPathParams[]) {\n  let openings = '';\n\n  const { innerWidth: w, innerHeight: h } = window;\n\n  overlayPaths.forEach((overlayPath) => {\n    const { width, height, x = 0, y = 0, r = 0 } = overlayPath;\n    const {\n      topLeft = 0,\n      topRight = 0,\n      bottomRight = 0,\n      bottomLeft = 0\n    } = typeof r === 'number'\n      ? { topLeft: r, topRight: r, bottomRight: r, bottomLeft: r }\n      : r;\n\n    openings += `M${x + topLeft},${y}\\\n      a${topLeft},${topLeft},0,0,0-${topLeft},${topLeft}\\\n      V${height + y - bottomLeft}\\\n      a${bottomLeft},${bottomLeft},0,0,0,${bottomLeft},${bottomLeft}\\\n      H${width + x - bottomRight}\\\n      a${bottomRight},${bottomRight},0,0,0,${bottomRight}-${bottomRight}\\\n      V${y + topRight}\\\n      a${topRight},${topRight},0,0,0-${topRight}-${topRight}\\\n      Z`;\n  });\n\n  return `M${w},${h}\\\n          H0\\\n          V0\\\n          H${w}\\\n          V${h}\\\n          Z\\\n          ${openings}`.replace(/\\s/g, '');\n}\n", "<script>\n  import { makeOverlayPath } from '../utils/overlay-path.ts';\n\n  export let element, openingProperties;\n  let modalIsVisible = false;\n  let rafId = undefined;\n  let pathDefinition;\n\n  $: pathDefinition = makeOverlayPath(openingProperties);\n\n  closeModalOpening();\n\n  export const getElement = () => element;\n\n  export function closeModalOpening() {\n    openingProperties = [\n      {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      }\n    ];\n  }\n\n  /**\n   * Hide the modal overlay\n   */\n  export function hide() {\n    modalIsVisible = false;\n\n    // Ensure we cleanup all event listeners when we hide the modal\n    _cleanupStepEventListeners();\n  }\n\n  /**\n   * Uses the bounds of the element we want the opening overtop of to set the dimensions of the opening and position it\n   * @param {Number} modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n   * @param {Number | { topLeft: Number, bottomLeft: Number, bottomRight: Number, topRight: Number }} modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n   * @param {Number} modalOverlayOpeningXOffset An amount to offset the modal overlay opening in the x-direction\n   * @param {Number} modalOverlayOpeningYOffset An amount to offset the modal overlay opening in the y-direction\n   * @param {HTMLElement} scrollParent The scrollable parent of the target element\n   * @param {HTMLElement} targetElement The element the opening will expose\n   */\n  export function positionModal(\n    modalOverlayOpeningPadding = 0,\n    modalOverlayOpeningRadius = 0,\n    modalOverlayOpeningXOffset = 0,\n    modalOverlayOpeningYOffset = 0,\n    scrollParent,\n    targetElement,\n    extraHighlights\n  ) {\n    if (targetElement) {\n      const elementsToHighlight = [targetElement, ...(extraHighlights || [])];\n      openingProperties = [];\n\n      for (const element of elementsToHighlight) {\n        if (!element) continue;\n\n        // Skip duplicate elements\n        if (\n          elementsToHighlight.indexOf(element) !==\n          elementsToHighlight.lastIndexOf(element)\n        ) {\n          continue;\n        }\n\n        const { y, height } = _getVisibleHeight(element, scrollParent);\n        const { x, width, left } = element.getBoundingClientRect();\n\n        // Check if the element is contained by another element\n        const isContained = elementsToHighlight.some((otherElement) => {\n          if (otherElement === element) return false;\n          const otherRect = otherElement.getBoundingClientRect();\n          return (\n            x >= otherRect.left &&\n            x + width <= otherRect.right &&\n            y >= otherRect.top &&\n            y + height <= otherRect.bottom\n          );\n        });\n\n        if (isContained) continue;\n\n        // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n        openingProperties.push({\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x:\n            (x || left) +\n            modalOverlayOpeningXOffset -\n            modalOverlayOpeningPadding,\n          y: y + modalOverlayOpeningYOffset - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      }\n    } else {\n      closeModalOpening();\n    }\n  }\n\n  /**\n   * If modal is enabled, setup the svg mask opening and modal overlay for the step\n   * @param {Step} step The step instance\n   */\n  export function setupForStep(step) {\n    // Ensure we move listeners from the previous step, before we setup new ones\n    _cleanupStepEventListeners();\n\n    if (step.tour.options.useModalOverlay) {\n      _styleForStep(step);\n      show();\n    } else {\n      hide();\n    }\n  }\n\n  /**\n   * Show the modal overlay\n   */\n  export function show() {\n    modalIsVisible = true;\n  }\n\n  const _preventModalBodyTouch = (e) => {\n    e.preventDefault();\n  };\n\n  const _preventModalOverlayTouch = (e) => {\n    e.stopPropagation();\n  };\n\n  /**\n   * Add touchmove event listener\n   * @private\n   */\n  function _addStepEventListeners() {\n    // Prevents window from moving on touch.\n    window.addEventListener('touchmove', _preventModalBodyTouch, {\n      passive: false\n    });\n  }\n\n  /**\n   * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n   * @private\n   */\n  function _cleanupStepEventListeners() {\n    if (rafId) {\n      cancelAnimationFrame(rafId);\n      rafId = undefined;\n    }\n\n    window.removeEventListener('touchmove', _preventModalBodyTouch, {\n      passive: false\n    });\n  }\n\n  /**\n   * Style the modal for the step\n   * @param {Step} step The step to style the opening for\n   * @private\n   */\n  function _styleForStep(step) {\n    const {\n      modalOverlayOpeningPadding,\n      modalOverlayOpeningRadius,\n      modalOverlayOpeningXOffset = 0,\n      modalOverlayOpeningYOffset = 0\n    } = step.options;\n\n    const iframeOffset = _getIframeOffset(step.target);\n    const scrollParent = _getScrollParent(step.target);\n\n    // Setup recursive function to call requestAnimationFrame to update the modal opening position\n    const rafLoop = () => {\n      rafId = undefined;\n      positionModal(\n        modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius,\n        modalOverlayOpeningXOffset + iframeOffset.left,\n        modalOverlayOpeningYOffset + iframeOffset.top,\n        scrollParent,\n        step.target,\n        step._resolvedExtraHighlightElements\n      );\n      rafId = requestAnimationFrame(rafLoop);\n    };\n\n    rafLoop();\n\n    _addStepEventListeners();\n  }\n\n  /**\n   * Find the closest scrollable parent element\n   * @param {HTMLElement} element The target element\n   * @returns {HTMLElement}\n   * @private\n   */\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n\n    const isHtmlElement = element instanceof HTMLElement;\n    const overflowY =\n      isHtmlElement && window.getComputedStyle(element).overflowY;\n    const isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n\n    return _getScrollParent(element.parentElement);\n  }\n\n  /**\n   * Get the top and left offset required to position the modal overlay cutout\n   * when the target element is within an iframe\n   * @param {HTMLElement} element The target element\n   * @private\n   */\n  function _getIframeOffset(element) {\n    let offset = {\n      top: 0,\n      left: 0\n    };\n\n    if (!element) {\n      return offset;\n    }\n\n    let targetWindow = element.ownerDocument.defaultView;\n\n    while (targetWindow !== window.top) {\n      const targetIframe = targetWindow?.frameElement;\n\n      if (targetIframe) {\n        const targetIframeRect = targetIframe.getBoundingClientRect();\n\n        offset.top += targetIframeRect.top + (targetIframeRect.scrollTop ?? 0);\n        offset.left +=\n          targetIframeRect.left + (targetIframeRect.scrollLeft ?? 0);\n      }\n\n      targetWindow = targetWindow.parent;\n    }\n\n    return offset;\n  }\n\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n  function _getVisibleHeight(element, scrollParent) {\n    const elementRect = element.getBoundingClientRect();\n    let top = elementRect.y || elementRect.top;\n    let bottom = elementRect.bottom || top + elementRect.height;\n\n    if (scrollParent) {\n      const scrollRect = scrollParent.getBoundingClientRect();\n      const scrollTop = scrollRect.y || scrollRect.top;\n      const scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n\n    const height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return { y: top, height };\n  }\n</script>\n\n<svg\n  bind:this={element}\n  class={`${\n    modalIsVisible ? 'shepherd-modal-is-visible' : ''\n  } shepherd-modal-overlay-container`}\n  on:touchmove={_preventModalOverlayTouch}\n>\n  <path d={pathDefinition} />\n</svg>\n\n<style global>\n  .shepherd-modal-overlay-container {\n    height: 0;\n    left: 0;\n    opacity: 0;\n    overflow: hidden;\n    pointer-events: none;\n    position: fixed;\n    top: 0;\n    transition:\n      all 0.3s ease-out,\n      height 0ms 0.3s,\n      opacity 0.3s 0ms;\n    width: 100vw;\n    z-index: 9997;\n  }\n\n  .shepherd-modal-overlay-container.shepherd-modal-is-visible {\n    height: 100vh;\n    opacity: 0.5;\n    transition:\n      all 0.3s ease-out,\n      height 0s 0s,\n      opacity 0.3s 0s;\n    transform: translateZ(0);\n  }\n\n  .shepherd-modal-overlay-container.shepherd-modal-is-visible path {\n    pointer-events: all;\n  }\n</style>\n", "import { Evented } from './evented.ts';\nimport { Step, type StepOptions } from './step.ts';\nimport autoBind from './utils/auto-bind.ts';\nimport {\n  isHTMLElement,\n  isFunction,\n  isString,\n  isUndefined\n} from './utils/type-check.ts';\nimport { cleanupSteps } from './utils/cleanup.ts';\nimport { normalizePrefix, uuid } from './utils/general.ts';\n// @ts-expect-error TODO: we don't have Svelte .d.ts files until we generate the dist\nimport ShepherdModal from './components/shepherd-modal.svelte';\n\nexport interface EventOptions {\n  previous?: Step | null;\n  step?: Step | null;\n  tour: Tour;\n}\n\nexport type TourConfirmCancel =\n  | boolean\n  | (() => boolean)\n  | Promise<boolean>\n  | (() => Promise<boolean>);\n\n/**\n * The options for the tour\n */\nexport interface TourOptions {\n  /**\n   * If true, will issue a `window.confirm` before cancelling.\n   * If it is a function(support Async Function), it will be called and wait for the return value,\n   * and will only be cancelled if the value returned is true.\n   */\n  confirmCancel?: TourConfirmCancel;\n  /**\n   * The message to display in the `window.confirm` dialog.\n   */\n  confirmCancelMessage?: string;\n  /**\n   * The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n   */\n  classPrefix?: string;\n  /**\n   * Default options for Steps ({@link Step#constructor}), created through `addStep`.\n   */\n  defaultStepOptions?: StepOptions;\n  /**\n   * Exiting the tour with the escape key will be enabled unless this is explicitly\n   * set to false.\n   */\n  exitOnEsc?: boolean;\n  /**\n   * Explicitly set the id for the tour. If not set, the id will be a generated uuid.\n   */\n  id?: string;\n  /**\n   * Navigating the tour via left and right arrow keys will be enabled\n   * unless this is explicitly set to false.\n   */\n  keyboardNavigation?: boolean;\n  /**\n   * An optional container element for the modal.\n   * If not set, the modal will be appended to `document.body`.\n   */\n  modalContainer?: HTMLElement;\n  /**\n   * An optional container element for the steps.\n   * If not set, the steps will be appended to `document.body`.\n   */\n  stepsContainer?: HTMLElement;\n  /**\n   * An array of step options objects or Step instances to initialize the tour with.\n   */\n  steps?: Array<StepOptions> | Array<Step>;\n  /**\n   * An optional \"name\" for the tour. This will be appended to the the tour's\n   * dynamically generated `id` property.\n   */\n  tourName?: string;\n  /**\n   * Whether or not steps should be placed above a darkened\n   * modal overlay. If true, the overlay will create an opening around the target element so that it\n   * can remain interactive\n   */\n  useModalOverlay?: boolean;\n}\n\nexport class ShepherdBase extends Evented {\n  activeTour?: Tour | null;\n  declare Step: typeof Step;\n  declare Tour: typeof Tour;\n\n  constructor() {\n    super();\n\n    autoBind(this);\n  }\n}\n\n/**\n * Class representing the site tour\n * @extends {Evented}\n */\nexport class Tour extends Evented {\n  trackedEvents = ['active', 'cancel', 'complete', 'show'];\n\n  classPrefix: string;\n  currentStep?: Step | null;\n  focusedElBeforeOpen?: HTMLElement | null;\n  id?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  modal?: any | null;\n  options: TourOptions;\n  steps: Array<Step>;\n\n  constructor(options: TourOptions = {}) {\n    super();\n\n    autoBind(this);\n\n    const defaultTourOptions = {\n      exitOnEsc: true,\n      keyboardNavigation: true\n    };\n\n    this.options = Object.assign({}, defaultTourOptions, options);\n    this.classPrefix = normalizePrefix(this.options.classPrefix);\n    this.steps = [];\n    this.addSteps(this.options.steps);\n\n    // Pass these events onto the global Shepherd object\n    const events = [\n      'active',\n      'cancel',\n      'complete',\n      'inactive',\n      'show',\n      'start'\n    ];\n    events.map((event) => {\n      ((e) => {\n        this.on(e, (opts?: { [key: string]: unknown }) => {\n          opts = opts || {};\n          opts['tour'] = this;\n          Shepherd.trigger(e, opts);\n        });\n      })(event);\n    });\n\n    this._setTourID(options.id);\n\n    return this;\n  }\n\n  /**\n   * Adds a new step to the tour\n   * @param {StepOptions} options - An object containing step options or a Step instance\n   * @param {number | undefined} index - The optional index to insert the step at. If undefined, the step\n   * is added to the end of the array.\n   * @return The newly added step\n   */\n  addStep(options: StepOptions | Step, index?: number) {\n    let step = options;\n\n    if (!(step instanceof Step)) {\n      step = new Step(this, step);\n    } else {\n      step.tour = this;\n    }\n\n    if (!isUndefined(index)) {\n      this.steps.splice(index, 0, step as Step);\n    } else {\n      this.steps.push(step as Step);\n    }\n\n    return step;\n  }\n\n  /**\n   * Add multiple steps to the tour\n   * @param {Array<StepOptions> | Array<Step> | undefined} steps - The steps to add to the tour\n   */\n  addSteps(steps?: Array<StepOptions> | Array<Step>) {\n    if (Array.isArray(steps)) {\n      steps.forEach((step) => {\n        this.addStep(step);\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Go to the previous step in the tour\n   */\n  back() {\n    const index = this.steps.indexOf(this.currentStep as Step);\n    this.show(index - 1, false);\n  }\n\n  /**\n   * Calls _done() triggering the 'cancel' event\n   * If `confirmCancel` is true, will show a window.confirm before cancelling\n   * If `confirmCancel` is a function, will call it and wait for the return value,\n   * and only cancel when the value returned is true\n   */\n  async cancel() {\n    if (this.options.confirmCancel) {\n      const cancelMessage =\n        this.options.confirmCancelMessage ||\n        'Are you sure you want to stop the tour?';\n      let stopTour;\n\n      if (isFunction(this.options.confirmCancel)) {\n        stopTour = await this.options.confirmCancel();\n      } else {\n        stopTour = window.confirm(cancelMessage);\n      }\n\n      if (stopTour) {\n        this._done('cancel');\n      }\n    } else {\n      this._done('cancel');\n    }\n  }\n\n  /**\n   * Calls _done() triggering the `complete` event\n   */\n  complete() {\n    this._done('complete');\n  }\n\n  /**\n   * Gets the step from a given id\n   * @param {number | string} id - The id of the step to retrieve\n   * @return The step corresponding to the `id`\n   */\n  getById(id: number | string) {\n    return this.steps.find((step) => {\n      return step.id === id;\n    });\n  }\n\n  /**\n   * Gets the current step\n   */\n  getCurrentStep() {\n    return this.currentStep;\n  }\n\n  /**\n   * Hide the current step\n   */\n  hide() {\n    const currentStep = this.getCurrentStep();\n\n    if (currentStep) {\n      return currentStep.hide();\n    }\n  }\n\n  /**\n   * Check if the tour is active\n   */\n  isActive() {\n    return Shepherd.activeTour === this;\n  }\n\n  /**\n   * Go to the next step in the tour\n   * If we are at the end, call `complete`\n   */\n  next() {\n    const index = this.steps.indexOf(this.currentStep as Step);\n\n    if (index === this.steps.length - 1) {\n      this.complete();\n    } else {\n      this.show(index + 1, true);\n    }\n  }\n\n  /**\n   * Removes the step from the tour\n   * @param {string} name - The id for the step to remove\n   */\n  removeStep(name: string) {\n    const current = this.getCurrentStep();\n\n    // Find the step, destroy it and remove it from this.steps\n    this.steps.some((step, i) => {\n      if (step.id === name) {\n        if (step.isOpen()) {\n          step.hide();\n        }\n\n        step.destroy();\n        this.steps.splice(i, 1);\n\n        return true;\n      }\n    });\n\n    if (current && current.id === name) {\n      this.currentStep = undefined;\n\n      // If we have steps left, show the first one, otherwise just cancel the tour\n      this.steps.length ? this.show(0) : this.cancel();\n    }\n  }\n\n  /**\n   * Show a specific step in the tour\n   * @param {number | string} key - The key to look up the step by\n   * @param {boolean} forward - True if we are going forward, false if backward\n   */\n  show(key: number | string = 0, forward = true) {\n    const step = isString(key) ? this.getById(key) : this.steps[key];\n\n    if (step) {\n      this._updateStateBeforeShow();\n\n      const shouldSkipStep =\n        isFunction(step.options.showOn) && !step.options.showOn();\n\n      // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n      if (shouldSkipStep) {\n        this._skipStep(step, forward);\n      } else {\n        this.currentStep = step;\n        this.trigger('show', {\n          step,\n          previous: this.currentStep\n        });\n\n        step.show();\n      }\n    }\n  }\n\n  /**\n   * Start the tour\n   */\n  async start() {\n    this.trigger('start');\n\n    // Save the focused element before the tour opens\n    this.focusedElBeforeOpen = document.activeElement as HTMLElement | null;\n\n    this.currentStep = null;\n\n    this.setupModal();\n\n    this._setupActiveTour();\n    this.next();\n  }\n\n  /**\n   * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n   * @param {string} event - The event name to trigger\n   * @private\n   */\n  _done(event: string) {\n    const index = this.steps.indexOf(this.currentStep as Step);\n    if (Array.isArray(this.steps)) {\n      this.steps.forEach((step) => step.destroy());\n    }\n\n    cleanupSteps(this);\n\n    this.trigger(event, { index });\n\n    Shepherd.activeTour = null;\n    this.trigger('inactive', { tour: this });\n\n    if (this.modal) {\n      this.modal.hide();\n    }\n\n    if (event === 'cancel' || event === 'complete') {\n      if (this.modal) {\n        const modalContainer = document.querySelector(\n          '.shepherd-modal-overlay-container'\n        );\n\n        if (modalContainer) {\n          modalContainer.remove();\n          this.modal = null;\n        }\n      }\n    }\n\n    // Focus the element that was focused before the tour started\n    if (isHTMLElement(this.focusedElBeforeOpen)) {\n      this.focusedElBeforeOpen.focus();\n    }\n  }\n\n  /**\n   * Make this tour \"active\"\n   */\n  _setupActiveTour() {\n    this.trigger('active', { tour: this });\n\n    Shepherd.activeTour = this;\n  }\n\n  /**\n   * setupModal create the modal container and instance\n   */\n  setupModal() {\n    this.modal = new ShepherdModal({\n      target: this.options.modalContainer || document.body,\n      props: {\n        // @ts-expect-error TODO: investigate where styles comes from\n        styles: this.styles\n      }\n    });\n  }\n\n  /**\n   * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n   * @param {Step} step - The step to skip\n   * @param {boolean} forward - True if we are going forward, false if backward\n   * @private\n   */\n  _skipStep(step: Step, forward: boolean) {\n    const index = this.steps.indexOf(step);\n\n    if (index === this.steps.length - 1) {\n      this.complete();\n    } else {\n      const nextIndex = forward ? index + 1 : index - 1;\n      this.show(nextIndex, forward);\n    }\n  }\n\n  /**\n   * Before showing, hide the current step and if the tour is not\n   * already active, call `this._setupActiveTour`.\n   * @private\n   */\n  _updateStateBeforeShow() {\n    if (this.currentStep) {\n      this.currentStep.hide();\n    }\n\n    if (!this.isActive()) {\n      this._setupActiveTour();\n    }\n  }\n\n  /**\n   * Sets this.id to a provided tourName and id or `${tourName}--${uuid}`\n   * @param {string} optionsId - True if we are going forward, false if backward\n   * @private\n   */\n  _setTourID(optionsId: string | undefined) {\n    const tourName = this.options.tourName || 'tour';\n    const tourId = optionsId || uuid();\n\n    this.id = `${tourName}--${tourId}`;\n  }\n}\n\n/**\n * @public\n */\nconst Shepherd = new ShepherdBase();\n\nexport { Shepherd };\n", "import { Shepherd, Tour } from './tour.ts';\nimport { StepNoOp, TourNoOp } from './utils/general.ts';\nimport { Step } from './step.ts';\n\nconst isServerSide = typeof window === 'undefined';\n\nShepherd.Step = (isServerSide ? StepNoOp : Step) as unknown as typeof Step;\nShepherd.Tour = (isServerSide ? TourNoOp : Tour) as unknown as typeof Tour;\n\nexport { ShepherdBase } from './tour.ts';\nexport default Shepherd;\n// Reexport types so they can be more easily used.\nexport type * from './evented.ts';\nexport type * from './step.ts';\nexport type * from './tour.ts';\n"],
  "mappings": "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",
  "names": ["isElement", "value", "Element", "isHTMLElement", "HTMLElement", "isFunction", "isString", "isUndefined", "undefined", "Evented", "on", "event", "handler", "ctx", "once", "_this$bindings$event", "bindings", "push", "off", "_this$bindings$event2", "forEach", "binding", "index", "_this$bindings$event3", "splice", "trigger", "args", "_this$bindings$event4", "context", "apply", "_this$bindings$event5", "actions", "defaultMerge", "Symbol", "skip", "defaultMetaDataUpdater", "previousMeta", "metaMeta", "defaultFilterValues", "values", "meta", "filter", "ObjectType", "getObjectType", "object", "Array", "isArray", "isRecord", "Set", "Map", "getKeys", "objects", "keys", "key", "Object", "getOwnPropertySymbols", "add", "objectHasProperty", "property", "prototype", "propertyIsEnumerable", "call", "getIterableOfIterables", "iterables", "iterator", "iterable", "validRecordToStringValues", "has", "toString", "constructor", "hasOwnProperty", "mergeRecords$1", "utils", "result", "propValues", "length", "updatedMeta", "metaDataUpdater", "parents", "propertyResult", "mergeUnknowns", "defineProperty", "configurable", "enumerable", "writable", "mergeArrays$1", "flat", "mergeSets$1", "mergeMaps$1", "mergeOthers$1", "at", "mergeFunctions", "mergeRecords", "mergeArrays", "mergeSets", "mergeMaps", "mergeOthers", "deepmerge", "deepmergeCustom", "options", "rootMetaData", "getUtils", "customizedDeepmerge", "_options$metaDataUpda", "_options$enableImplic", "_options$filterValues", "defaultMergeFunctions", "_extends", "fromEntries", "entries", "option", "hasOwn", "map", "useImplicitDefaultMerging", "enableImplicitDefaultMerging", "filterValues", "_utils$filterValues", "filteredValues", "type", "m_index", "autoBind", "self", "getOwnPropertyNames", "i", "val", "bind", "_setupAdvanceOnHandler", "step", "selector", "isOpen", "targetIsEl", "el", "currentTarget", "targetIsSelector", "matches", "tour", "next", "bindAdvance", "advanceOn", "document", "querySelector", "console", "error", "addEventListener", "removeEventListener", "body", "StepNoOp", "_options", "TourNoOp", "_tour", "normalizePrefix", "prefix", "charAt", "parseAttachTo", "attachTo", "returnOpts", "assign", "element", "e", "parseExtraHighlights", "extraHighlights", "flatMap", "highlight", "from", "querySelectorAll", "shouldCenterStep", "resolvedAttachToOptions", "uuid", "d", "Date", "now", "replace", "c", "r", "Math", "random", "floor", "sides", "alignments", "placements", "reduce", "acc", "side", "concat", "min", "max", "round", "createCoords", "v", "x", "y", "oppositeSideMap", "left", "right", "bottom", "top", "oppositeAlignmentMap", "start", "end", "clamp", "evaluate", "param", "getSide", "placement", "split", "getAlignment", "getOppositeAxis", "axis", "getAxisLength", "getSideAxis", "includes", "getAlignmentAxis", "getAlignmentSides", "rects", "rtl", "alignment", "alignmentAxis", "mainAlignmentSide", "reference", "floating", "getOppositePlacement", "getExpandedPlacements", "oppositePlacement", "getOppositeAlignmentPlacement", "getSideList", "isStart", "lr", "rl", "tb", "bt", "getOppositeAxisPlacements", "flipAlignment", "direction", "list", "expandPaddingObject", "padding", "getPaddingObject", "rectToClientRect", "rect", "width", "height", "computeCoordsFromPlacement", "_ref", "sideAxis", "alignLength", "isVertical", "commonX", "commonY", "commonAlign", "coords", "computePosition", "config", "strategy", "middleware", "platform", "validMiddleware", "Boolean", "isRTL", "getElementRects", "statefulPlacement", "middlewareData", "resetCount", "name", "fn", "nextX", "nextY", "data", "reset", "initialPlacement", "elements", "detectOverflow", "state", "_await$platform$isEle", "boundary", "rootBoundary", "elementContext", "altBoundary", "paddingObject", "altContext", "clippingClientRect", "getClippingRect", "contextElement", "getDocumentElement", "offsetParent", "getOffsetParent", "offsetScale", "getScale", "elementClientRect", "convertOffsetParentRelativeRectToViewportRelativeRect", "arrow", "arrowDimensions", "getDimensions", "isYAxis", "minProp", "maxProp", "clientProp", "endDiff", "startDiff", "arrowOffsetParent", "clientSize", "centerToReference", "largestPossiblePadding", "minPadding", "maxPadding", "min$1", "center", "offset", "shouldAddOffset", "alignmentOffset", "centerOffset", "getPlacementList", "autoAlignment", "allowedPlacements", "allowedPlacementsSortedByAlignment", "autoPlacement", "_middlewareData$autoP", "_middlewareData$autoP2", "_placementsThatFitOnE", "_evaluate", "crossAxis", "detectOverflowOptions", "_objectWithoutPropertiesLoose", "_excluded", "placements$1", "overflow", "currentIndex", "currentPlacement", "alignmentSides", "currentOverflows", "allOverflows", "overflows", "nextPlacement", "placementsSortedByMostSpace", "slice", "sort", "a", "b", "placementsThatFitOnEachSide", "every", "resetPlacement", "flip", "_middlewareData$arrow", "_middlewareData$flip", "_evaluate2", "mainAxis", "checkMainAxis", "checkCrossAxis", "fallbackPlacements", "specifiedFallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "_excluded2", "initialSideAxis", "isBasePlacement", "hasFallbackAxisSideDirection", "overflowsData", "_middlewareData$flip2", "_overflowsData$filter", "nextIndex", "_overflowsData$", "ignoreCrossAxisOverflow", "hasInitialMainAxisOverflow", "_overflowsData$filter2", "currentSideAxis", "shift", "_evaluate4", "limiter", "_excluded4", "mainAxisCoord", "crossAxisCoord", "minSide", "maxSide", "limitedCoords", "enabled", "limitShift", "rawOffset", "computedOffset", "len", "limitMin", "limitMax", "_middlewareData$offse", "_middlewareData$offse2", "isOriginSide", "hasWindow", "window", "getNodeName", "node", "isNode", "nodeName", "toLowerCase", "getWindow", "_node$ownerDocument", "ownerDocument", "defaultView", "documentElement", "Node", "isShadowRoot", "ShadowRoot", "isOverflowElement", "overflowX", "overflowY", "display", "getComputedStyle", "test", "isTableElement", "isTopLayer", "some", "isContainingBlock", "elementOrCss", "webkit", "isWebKit", "css", "containerType", "backdropFilter", "willChange", "contain", "getContainingBlock", "currentNode", "getParentNode", "isLastTraversableNode", "CSS", "supports", "getNodeScroll", "scrollLeft", "scrollTop", "scrollX", "scrollY", "assignedSlot", "parentNode", "host", "getNearestOverflowAncestor", "getOverflowAncestors", "traverseIframes", "_node$ownerDocument2", "scrollableAncestor", "isBody", "win", "frameElement", "getFrameElement", "visualViewport", "parent", "getPrototypeOf", "getCssDimensions", "parseFloat", "hasOffset", "offsetWidth", "offsetHeight", "shouldFallback", "$", "unwrapElement", "domElement", "getBoundingClientRect", "Number", "isFinite", "noOffsets", "getVisualOffsets", "offsetLeft", "offsetTop", "shouldAddVisualOffsets", "isFixed", "floatingOffsetParent", "includeScale", "isFixedStrategy", "clientRect", "scale", "visualOffsets", "offsetWin", "currentWin", "currentIFrame", "iframeScale", "iframeRect", "clientLeft", "paddingLeft", "clientTop", "paddingTop", "getWindowScrollBarX", "leftScroll", "getHTMLOffset", "scroll", "ignoreScrollbarX", "htmlRect", "topLayer", "offsets", "isOffsetParentAnElement", "offsetRect", "htmlOffset", "getClientRects", "getDocumentRect", "html", "scrollWidth", "clientWidth", "scrollHeight", "clientHeight", "getViewportRect", "visualViewportBased", "getInnerBoundingClientRect", "getClientRectFromClippingAncestor", "clippingAncestor", "hasFixedPositionAncestor", "stopNode", "position", "getClippingElementAncestors", "cache", "cachedResult", "get", "currentContainingBlockComputedStyle", "elementIsFixed", "computedStyle", "currentNodeIsContaining", "shouldDropCurrentNode", "ancestor", "set", "elementClippingAncestors", "_c", "clippingAncestors", "firstClippingAncestor", "clippingRect", "accRect", "getRectRelativeToOffsetParent", "setLeftRTLScrollbarOffset", "isStaticPositioned", "getTrueOffsetParent", "polyfill", "rawOffsetParent", "svgOffsetParent", "getOffsetParentFn", "getDimensionsFn", "floatingDimensions", "rectsAreEqual", "observeMove", "onMove", "io", "timeoutId", "root", "cleanup", "_io", "clearTimeout", "disconnect", "refresh", "threshold", "elementRectForRootMargin", "insetTop", "insetRight", "insetBottom", "insetLeft", "rootMargin", "isFirstUpdate", "handleObserve", "ratio", "intersectionRatio", "setTimeout", "IntersectionObserver", "_e", "observe", "autoUpdate", "update", "ancestorScroll", "ancestorResize", "elementResize", "ResizeObserver", "layoutShift", "animationFrame", "referenceEl", "ancestors", "passive", "cleanupIo", "reobserveFrame", "resizeObserver", "firstEntry", "target", "unobserve", "cancelAnimationFrame", "requestAnimationFrame", "_resizeObserver", "frameId", "prevRefRect", "frameLoop", "nextRefRect", "_resizeObserver2", "autoPlacement$1", "shift$1", "flip$1", "arrow$1", "limitShift$1", "mergedOptions", "platformWithCache", "computePosition$1", "setupTooltip", "attachToOptions", "_getResolvedAttachToOptions", "floatingUIOptions", "getFloatingUIOptions", "shouldCenter", "content", "shepherdElementComponent", "getElement", "classList", "setPosition", "mergeTooltipConfig", "tourOptions", "destroyTooltip", "then", "floatingUIposition", "Promise", "resolve", "tabIndex", "focus", "preventScroll", "style", "transform", "dataset", "placeArrow", "arrowEl", "arrowX", "arrowY", "_attachToOptions$on", "_attachToOptions$on2", "_attachToOptions$on3", "addArrow", "hasAutoPlacement", "hasEdgeAlignment", "_attachToOptions$on4", "pop", "arrowOptions", "noop", "tar", "src", "k", "run", "blank_object", "create", "run_all", "fns", "is_function", "thing", "safe_not_equal", "is_empty", "obj", "append", "appendChild", "insert", "anchor", "insertBefore", "detach", "removeChild", "destroy_each", "iterations", "detaching", "createElement", "svg_element", "createElementNS", "text", "createTextNode", "space", "empty", "listen", "attr", "attribute", "removeAttribute", "getAttribute", "setAttribute", "always_set_through_set_attribute", "set_attributes", "attributes", "descriptors", "getOwnPropertyDescriptors", "__proto__", "cssText", "indexOf", "children", "childNodes", "toggle_class", "toggle", "current_component", "set_current_component", "component", "get_current_component", "Error", "onMount", "$$", "on_mount", "afterUpdate", "after_update", "onDestroy", "on_destroy", "dirty_components", "binding_callbacks", "render_callbacks", "flush_callbacks", "resolved_promise", "update_scheduled", "schedule_update", "flush", "add_render_callback", "seen_callbacks", "flushidx", "saved_component", "callback", "clear", "fragment", "before_update", "dirty", "p", "flush_render_callbacks", "filtered", "targets", "outroing", "outros", "group_outros", "check_outros", "transition_in", "block", "local", "delete", "transition_out", "o", "ensure_array_like", "array_like_or_iterator", "get_spread_update", "levels", "updates", "to_null_out", "accounted_for", "$$scope", "n", "create_component", "mount_component", "m", "new_on_destroy", "destroy_component", "make_dirty", "fill", "init", "instance", "create_fragment", "not_equal", "props", "append_styles", "parent_component", "bound", "on_disconnect", "callbacks", "skip_bound", "ready", "ret", "rest", "hydrate", "nodes", "l", "intro", "SvelteComponent", "$$set", "$destroy", "$on", "$set", "PUBLIC_VERSION", "__svelte", "button", "button_class_value", "arguments", "$$props", "action", "classes", "disabled", "label", "secondary", "getConfigOption", "$$invalidate", "each_blocks", "create_if_block", "footer", "buttons", "button_aria_label_value", "span", "cancelIcon", "handleCancelClick", "preventDefault", "cancel", "h3", "labelId", "title", "innerHTML", "$$value", "create_if_block_1", "header", "div", "descriptionId", "show_if_2", "show_if_1", "show_if", "dialog_aria_describedby_value", "dialog", "current", "KEY_TAB", "KEY_ESC", "LEFT_ARROW", "RIGHT_ARROW", "getClassesArray", "className", "attachToElement", "attachTofocusableDialogElements", "classPrefix", "focusableAttachToElements", "firstFocusableAttachToElement", "lastFocusableAttachToElement", "firstFocusableDialogElement", "focusableDialogElements", "lastFocusableDialogElement", "dataStepId", "hasCancelIcon", "hasTitle", "id", "handleKeyDown", "_attachToElement", "updateDynamicClasses", "removeClasses", "addClasses", "oldClasses", "remove", "newClasses", "keyCode", "shiftKey", "activeElement", "contains", "_lastFocusableAttachT", "_firstFocusableAttach", "exitOnEsc", "stopPropagation", "keyboardNavigation", "back", "Step", "_resolvedAttachTo", "_resolvedExtraHighlightElements", "styles", "_setOptions", "complete", "destroy", "_updateStepTargetOnHide", "getTour", "hide", "_this$tour$modal", "modal", "hidden", "_resolveExtraHiglightElements", "_resolveAttachToOptions", "show", "beforeShowPromise", "_show", "updateStepOptions", "getTarget", "_createTooltipContent", "ShepherdElement", "stepsContainer", "_scrollTo", "scrollToOptions", "scrollToHandler", "scrollIntoView", "_getClassOptions", "stepOptions", "defaultStepOptions", "stepClasses", "defaultStepOptionsClasses", "allClasses", "uniqClasses", "join", "trim", "when", "_setupElements", "_this$tour$modal2", "setupModal", "setupForStep", "_styleTargetElementForStep", "scrollTo", "extraHighlightElements", "targetElement", "highlightClass", "canClickTarget", "cleanupSteps", "steps", "makeOverlayPath", "overlayPaths", "openings", "innerWidth", "w", "innerHeight", "h", "overlayPath", "topLeft", "topRight", "bottomRight", "bottomLeft", "svg", "path", "_getScrollParent", "isHtmlElement", "isScrollable", "parentElement", "_getIframeOffset", "targetWindow", "_targetWindow", "targetIframe", "_targetIframeRect$scr", "_targetIframeRect$scr2", "targetIframeRect", "_getVisibleHeight", "scrollParent", "elementRect", "scrollRect", "scrollBottom", "openingProperties", "modalIsVisible", "rafId", "pathDefinition", "closeModalOpening", "_cleanupStepEventListeners", "positionModal", "modalOverlayOpeningPadding", "modalOverlayOpeningRadius", "modalOverlayOpeningXOffset", "modalOverlayOpeningYOffset", "elementsToHighlight", "lastIndexOf", "isContained", "otherElement", "otherRect", "useModalOverlay", "_styleForStep", "_preventModalBodyTouch", "_preventModalOverlayTouch", "_addStepEventListeners", "iframeOffset", "rafLoop", "ShepherdBase", "activeTour", "Tour", "trackedEvents", "currentStep", "focusedElBeforeOpen", "defaultTourOptions", "addSteps", "events", "opts", "Shepherd", "_setTourID", "addStep", "confirmCancel", "cancelMessage", "confirmCancelMessage", "stopTour", "confirm", "_done", "getById", "find", "getCurrentStep", "isActive", "removeStep", "forward", "_updateStateBeforeShow", "shouldSkipStep", "showOn", "_skipStep", "previous", "_setupActiveTour", "modalContainer", "ShepherdModal", "optionsId", "tourName", "tourId", "isServerSide"]
}
